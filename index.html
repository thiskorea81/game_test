<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>솔저 러너 (Soldier Runner) - 보스 & 무기 모드</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #333; /* 도로 색상 */
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #score-board {
            margin-top: 20px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            padding: 5px 15px;
            border-radius: 15px;
        }

        #boss-hp-bar-container {
            display: none; /* 보스전일 때만 표시 */
            width: 80%;
            max-width: 400px;
            height: 20px;
            background: #555;
            border: 2px solid white;
            border-radius: 10px;
            margin-top: 10px;
            overflow: hidden;
        }

        #boss-hp-bar {
            width: 100%;
            height: 100%;
            background: #ff0055;
            transition: width 0.1s linear;
        }

        #level-indicator {
            margin-top: 10px;
            font-size: 18px;
            color: #ffff00;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }

        #start-screen, #game-over-screen, #win-screen, #level-complete-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px 40px;
            border-radius: 20px;
            border: 4px solid #0055ff;
            pointer-events: auto;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            width: 80%;
            max-width: 400px;
        }

        #win-screen {
            border-color: #00ff00;
            background: rgba(240, 255, 240, 0.95);
        }

        #win-screen h1 {
            color: #00aa00;
        }

        #level-complete-screen {
            border-color: #ffaa00;
        }
        
        #level-complete-screen h1 {
            color: #ffaa00;
        }

        h1 {
            margin: 0 0 15px 0;
            color: #0055ff;
            font-size: 28px;
            text-transform: uppercase;
        }

        p {
            font-size: 16px;
            color: #444;
            line-height: 1.5;
            margin-bottom: 20px;
        }

        .highlight {
            color: #ff0055;
            font-weight: bold;
        }

        .blue-highlight {
            color: #0055ff;
            font-weight: bold;
        }
        
        .green-highlight {
            color: #00aa00;
            font-weight: bold;
        }

        button {
            background: #0055ff;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 4px 0 #003399;
        }
        
        #next-level-btn {
            background: #ffaa00;
            box-shadow: 0 4px 0 #cc8800;
        }
        
        #next-level-btn:hover {
             background: #ffcc00;
        }

        button:hover {
            background: #1a6dff;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(2px);
            box-shadow: none;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="score-board">병력: <span id="soldier-count">1</span></div>
        <div id="level-indicator">LEVEL <span id="level-val">1</span> / 20</div>
        <!-- 보스 체력바 -->
        <div id="boss-hp-bar-container">
            <div id="boss-hp-bar"></div>
        </div>
    </div>

    <div id="start-screen">
        <h1>BOSS & WEAPON MOD</h1>
        <p>
            각 레벨의 끝에 <span class="highlight">강력한 보스</span>가 등장합니다!<br>
            <span style="color:#e6b800; font-weight:bold;">[M] 머신건</span>, <span style="color:#e6b800; font-weight:bold;">[S] 샷건</span> 아이템을 획득하세요.<br>
            마우스/터치로 레인을 바꿔 보스를 공격하세요!
        </p>
        <button id="start-btn">작전 시작</button>
    </div>
    
    <div id="level-complete-screen" class="hidden">
        <h1>BOSS DEFEATED!</h1>
        <p>
            레벨 <span id="completed-level-val">1</span> 작전 성공.<br>
            현재 병력: <span id="current-units">0</span>
        </p>
        <button id="next-level-btn">다음 작전으로</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>MISSION FAILED</h1>
        <p>도달 레벨: <span id="final-level">1</span></p>
        <button id="restart-btn">재도전</button>
    </div>

    <div id="win-screen" class="hidden">
        <h1>MISSION COMPLETE!</h1>
        <p>축하합니다! 모든 좀비와 보스를 물리쳤습니다.<br>최종 병력: <span id="win-score">0</span></p>
        <button id="win-restart-btn">다시 하기</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const soldierCountEl = document.getElementById('soldier-count');
        const levelValEl = document.getElementById('level-val');
        const finalLevelEl = document.getElementById('final-level');
        const winScoreEl = document.getElementById('win-score');
        
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const winScreen = document.getElementById('win-screen');
        const levelCompleteScreen = document.getElementById('level-complete-screen');
        const completedLevelValEl = document.getElementById('completed-level-val');
        const currentUnitsEl = document.getElementById('current-units');
        
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const winRestartBtn = document.getElementById('win-restart-btn');
        const nextLevelBtn = document.getElementById('next-level-btn');

        const bossHpContainer = document.getElementById('boss-hp-bar-container');
        const bossHpBar = document.getElementById('boss-hp-bar');

        // 게임 설정
        let gameState = 'start'; // start, playing, boss_fight, level_complete, gameover, win
        let baseGameSpeed = 3; // 기본 속도를 4에서 3으로 낮춤 (더 쉬움)
        let gameSpeed = baseGameSpeed;
        
        // 레벨 시스템 변수
        let currentLevel = 1;
        const maxLevel = 20;
        let levelTimer = 0;
        const levelDuration = 360; // 약 6초 후 보스 등장

        let spawnTimer = 0;
        let animationId;
        
        // 터치/마우스 입력
        let inputX = 0;

        // 객체 관리
        let playerGroup;
        let bullets = [];
        let enemies = [];
        let gates = [];
        let items = [];
        let particles = [];
        let roadMarkings = [];
        let currentBoss = null;
        
        // 보스 총알 배열 추가
        let bossBullets = [];

        // 레인 정보
        let leftLaneX;
        let rightLaneX;
        let laneWidth;

        function resize() {
            canvas.width = Math.min(window.innerWidth, 600); 
            canvas.height = window.innerHeight;
            inputX = canvas.width / 2;

            laneWidth = canvas.width / 2;
            leftLaneX = laneWidth / 2;
            rightLaneX = laneWidth + laneWidth / 2;
            
            if (playerGroup) {
                playerGroup.targetX = inputX < canvas.width / 2 ? leftLaneX : rightLaneX;
            }
        }
        window.addEventListener('resize', resize);
        resize();

        function handleInputMove(clientX) {
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            inputX = Math.max(0, Math.min(canvas.width, x));
        }

        window.addEventListener('mousemove', (e) => {
            if(gameState === 'playing' || gameState === 'boss_fight') handleInputMove(e.clientX);
        });
        window.addEventListener('touchmove', (e) => {
            if(gameState === 'playing' || gameState === 'boss_fight') handleInputMove(e.touches[0].clientX);
        }, {passive: false});
        window.addEventListener('touchstart', (e) => {
             if(gameState === 'playing' || gameState === 'boss_fight') handleInputMove(e.touches[0].clientX);
        }, {passive: false});


        // 클래스: 플레이어 그룹
        class PlayerGroup {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height - 150;
                this.count = 1;
                this.width = 40;
                this.shootTimer = 0;
                this.targetX = this.x;
                
                // 무기 시스템
                this.weaponType = 'normal'; // normal, machinegun, shotgun
                this.weaponTimer = 0; 
            }

            setWeapon(type) {
                this.weaponType = type;
                this.shootTimer = 0; // 즉시 발사 가능
            }

            update() {
                this.targetX = inputX < canvas.width / 2 ? leftLaneX : rightLaneX;
                this.x += (this.targetX - this.x) * 0.2;
                this.width = 40 + Math.min(this.count * 2, 120);

                // 자동 발사 로직
                this.shootTimer++;
                
                let fireRate = 20; // Default (느림)
                
                if (this.weaponType === 'machinegun') {
                    fireRate = 5; // 아주 빠름
                } else if (this.weaponType === 'shotgun') {
                    fireRate = 30; // 느림
                } else {
                    // Normal: 인원수 많으면 조금 빨라짐
                    fireRate = Math.max(8, 20 - Math.floor(this.count / 10));
                }

                if (this.shootTimer > fireRate) {
                    this.shoot();
                    this.shootTimer = 0;
                }
            }

            shoot() {
                let bulletCount = Math.min(this.count, 8); 
                let spread = this.width;

                if (this.weaponType === 'shotgun') {
                    // 샷건: 한 번에 3발씩 퍼지게 발사
                    for(let i=0; i<bulletCount; i++) {
                         let offsetX = (Math.random() - 0.5) * spread;
                         // 중앙, 좌, 우
                         bullets.push(new Bullet(this.x + offsetX, this.y, 0, 'shotgun'));
                         bullets.push(new Bullet(this.x + offsetX, this.y, -2, 'shotgun'));
                         bullets.push(new Bullet(this.x + offsetX, this.y, 2, 'shotgun'));
                    }
                } else {
                    // 일반 & 머신건: 직사
                    for(let i=0; i<bulletCount; i++) {
                        let offsetX = (Math.random() - 0.5) * spread;
                        bullets.push(new Bullet(this.x + offsetX, this.y, 0, this.weaponType));
                    }
                }
            }

            draw() {
                ctx.fillStyle = '#0055ff';
                const soldierSize = 8;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, soldierSize + 2, 0, Math.PI*2);
                ctx.fill();

                let drawCount = Math.min(this.count - 1, 30);
                for(let i=0; i<drawCount; i++) {
                    let angle = (Date.now() / 200) + (i * (Math.PI * 2 / drawCount));
                    let dist = 15 + (i % 2) * 10;
                    ctx.beginPath();
                    ctx.arc(this.x + Math.cos(angle)*dist, this.y + Math.sin(angle)*dist, soldierSize, 0, Math.PI*2);
                    ctx.fill();
                }

                ctx.fillStyle = 'white';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.count, this.x, this.y - 25);
                
                // 무기 상태 표시
                if (this.weaponType !== 'normal') {
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = '#ffff00';
                    ctx.fillText(this.weaponType === 'machinegun' ? "MACHINE GUN" : "SHOTGUN", this.x, this.y - 45);
                }
            }
        }

        // 보스 총알 클래스 추가
        class BossBullet {
            constructor(x, y, vx, vy) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.radius = 8;
                this.color = '#aa00ff'; // 보라색 에너지탄
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fill();
                
                // 광원 효과
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        class Bullet {
            constructor(x, y, vx = 0, type = 'normal') {
                this.x = x;
                this.y = y;
                this.radius = 3;
                this.speed = 15;
                this.vx = vx; // X축 속도 (샷건용)
                this.type = type;
                
                if (type === 'shotgun') {
                    this.damage = 1.5;
                    this.color = '#ffaa00';
                    this.radius = 4;
                } else if (type === 'machinegun') {
                    this.damage = 0.6; // 데미지는 낮지만 연사 빠름
                    this.color = '#00ffff';
                    this.radius = 2.5;
                } else {
                    this.damage = 1;
                    this.color = '#ffcc00';
                }
            }

            update() {
                this.y -= this.speed;
                this.x += this.vx;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fill();
            }
        }

        class Item {
            constructor() {
                this.size = 40;
                this.x = (Math.random() < 0.5 ? leftLaneX : rightLaneX) - this.size / 2;
                this.y = -50;
                this.speed = gameSpeed;
                this.type = Math.random() < 0.5 ? 'machinegun' : 'shotgun';
            }
            
            update() {
                // this.y += this.speed; // 외부 루프에서 처리
            }
            
            draw() {
                // 아이템 박스
                ctx.fillStyle = '#e6b800'; // Gold
                ctx.fillRect(this.x, this.y, this.size, this.size);
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.strokeRect(this.x, this.y, this.size, this.size);
                
                // 텍스트
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.type === 'machinegun' ? 'M' : 'S', this.x + this.size/2, this.y + 28);
            }
        }

        class Enemy {
            constructor() {
                this.size = 40 + Math.random() * 20;
                this.x = (Math.random() < 0.5 ? leftLaneX : rightLaneX) - this.size / 2;
                this.y = -100;
                let hpMultiplier = 1 + (currentLevel * 0.5);
                this.hp = Math.floor((5 + Math.random() * 5) * hpMultiplier); 
                this.maxHp = this.hp;
                this.speed = gameSpeed * 0.8; 
                this.color = '#ff0055';
            }
            update() {}
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.hp, this.x + this.size/2, this.y + this.size/2 + 5);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.size, this.size);
            }
        }

        class Boss {
            constructor(level) {
                this.width = 100;
                this.height = 100;
                this.x = canvas.width / 2 - this.width / 2;
                this.y = -150; // 위에서 내려옴
                this.targetY = 80;
                
                // 보스 체력: 레벨 * 100 + 플레이어 수에 비례
                // 플레이어가 많으면 체력이 더 많아야 순삭 방지
                // 난이도 하향: 기본 체력 계수 150 -> 100
                this.maxHp = (level * 100) + (playerGroup.count * 10);
                this.hp = this.maxHp;
                
                this.moveTimer = 0;
                this.lane = 'center'; // left, right, center
                this.state = 'entering'; // entering, fight
                
                // 공격 타이머
                this.attackTimer = 0;
                // 난이도 하향: 초기 공격 간격 90 -> 120 (더 느리게 쏨)
                this.attackInterval = Math.max(40, 120 - (level * 3)); 
            }

            update() {
                if (this.state === 'entering') {
                    this.y += (this.targetY - this.y) * 0.05;
                    if (Math.abs(this.y - this.targetY) < 5) {
                        this.state = 'fight';
                    }
                } else {
                    // 좌우 이동 패턴
                    this.moveTimer++;
                    if (this.moveTimer > 120) { // 2초마다 이동
                        this.moveTimer = 0;
                        const rand = Math.random();
                        if (rand < 0.5) this.targetX = leftLaneX - this.width/2;
                        else this.targetX = rightLaneX - this.width/2;
                    }
                    
                    if (this.targetX !== undefined) {
                        this.x += (this.targetX - this.x) * 0.1;
                    }

                    // 공격 패턴
                    this.attackTimer++;
                    if (this.attackTimer > this.attackInterval) {
                        this.shoot();
                        this.attackTimer = 0;
                    }
                }
            }

            shoot() {
                // 플레이어 방향 계산
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height;
                
                const dx = playerGroup.x - centerX;
                const dy = playerGroup.y - centerY;
                const angle = Math.atan2(dy, dx);
                const speed = 10; // 탄속

                // 기본 발사 (조준 사격)
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                bossBullets.push(new BossBullet(centerX, centerY, vx, vy));

                // 고레벨 패턴: 산탄 발사 (레벨 5 이상)
                if (currentLevel >= 5) {
                     const spreadAngle = 0.3; // 벌어지는 각도
                     bossBullets.push(new BossBullet(centerX, centerY, Math.cos(angle - spreadAngle) * speed, Math.sin(angle - spreadAngle) * speed));
                     bossBullets.push(new BossBullet(centerX, centerY, Math.cos(angle + spreadAngle) * speed, Math.sin(angle + spreadAngle) * speed));
                }
            }

            draw() {
                // 보스 몸체
                ctx.fillStyle = '#aa0033';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // 눈 (화난 표정)
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.moveTo(this.x + 20, this.y + 30);
                ctx.lineTo(this.x + 40, this.y + 40);
                ctx.lineTo(this.x + 40, this.y + 25);
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(this.x + this.width - 20, this.y + 30);
                ctx.lineTo(this.x + this.width - 40, this.y + 40);
                ctx.lineTo(this.x + this.width - 40, this.y + 25);
                ctx.fill();

                // 테두리
                ctx.lineWidth = 5;
                ctx.strokeStyle = '#ff0000';
                ctx.strokeRect(this.x, this.y, this.width, this.height);

                // "BOSS" 텍스트
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("BOSS", this.x + this.width/2, this.y - 10);
            }
        }

        class Gate {
            constructor() {
                this.width = laneWidth * 0.8;
                this.height = 10;
                this.x = (Math.random() < 0.5 ? leftLaneX : rightLaneX) - this.width / 2;
                this.y = -50;
                this.speed = gameSpeed;
                this.isPositive = false;
                this.hp = 5;
                this.type = 'sub';
                this.value = Math.floor(Math.random() * (5 + currentLevel)) + (5 + currentLevel);
            }

            hit() {
                if (this.isPositive) return;
                this.hp--;
                if (this.hp <= 0) this.transformToPositive();
            }

            transformToPositive() {
                this.isPositive = true;
                createParticles(this.x + this.width / 2, this.y + 40, '#0088ff', 20);
                const rand = Math.random();
                if (rand < 0.7) {
                    this.type = 'add';
                    this.value = Math.floor(Math.random() * (10 + currentLevel * 2)) + (10 + currentLevel);
                } else {
                    this.type = 'mult';
                    this.value = Math.floor(Math.random() * 2) + 2;
                }
            }

            update() {}
            draw() {
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = !this.isPositive ? '#ff3333' : '#0088ff';
                ctx.fillRect(this.x, this.y, this.width, 80);
                ctx.globalAlpha = 1.0;

                ctx.fillStyle = 'white';
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                let text = (this.type === 'add' ? '+' : (this.type === 'mult' ? 'x' : '-')) + this.value;
                ctx.fillText(text, this.x + this.width/2, this.y + 50);

                 if (!this.isPositive) {
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText(`HP: ${this.hp}`, this.x + this.width/2, this.y + 75);
                }

                ctx.lineWidth = 3;
                ctx.strokeStyle = 'white';
                ctx.strokeRect(this.x, this.y, this.width, 80);
            }
        }

        class RoadMark {
            constructor() {
                this.x = canvas.width / 2 - 2;
                this.y = -100;
                this.width = 4;
                this.height = 60;
                this.speed = gameSpeed;
            }
            update() {}
            draw() {
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        function spawnEnemy() {
            if (gameState === 'boss_fight') return; // 보스전엔 소환 안함

            let difficulty = currentLevel / maxLevel; 
            
            // 난이도 하향: 적 생성 확률 대폭 감소
            // 기존: 0.02 (2%) 시작 -> 변경: 0.005 (0.5%) 시작
            let spawnChance = 0.005 + (difficulty * 0.1);
            if (Math.random() < spawnChance) enemies.push(new Enemy());

            // 난이도 하향: 게이트(도움) 생성 확률 증가
            let gateChance = 0.02 + (difficulty * 0.01);
            if (Math.random() < gateChance) gates.push(new Gate());

            // 아이템 생성 (가끔)
            if (Math.random() < 0.005) items.push(new Item());

            if (roadMarkings.length === 0 || roadMarkings[roadMarkings.length-1].y > 200) {
                roadMarkings.push(new RoadMark());
            }
        }

        function checkCollisions() {
            // 총알 처리
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                let bulletHit = false;

                // 보스 충돌
                if (gameState === 'boss_fight' && currentBoss) {
                    if (b.x > currentBoss.x && b.x < currentBoss.x + currentBoss.width &&
                        b.y > currentBoss.y && b.y < currentBoss.y + currentBoss.height) {
                        
                        currentBoss.hp -= b.damage;
                        bulletHit = true;
                        createParticles(b.x, b.y, '#ffaa00', 1);
                        
                        if (currentBoss.hp <= 0) {
                            createParticles(currentBoss.x + currentBoss.width/2, currentBoss.y + currentBoss.height/2, '#aa0033', 50);
                            currentBoss = null;
                            completeLevel();
                        }
                    }
                }

                // 적 충돌
                if (!bulletHit) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        let e = enemies[j];
                        if (b.x > e.x && b.x < e.x + e.size &&
                            b.y > e.y && b.y < e.y + e.size) {
                            
                            e.hp -= b.damage;
                            bulletHit = true;
                            createParticles(b.x, b.y, '#ff0055', 2);
                            if (e.hp <= 0) {
                                createParticles(e.x + e.size/2, e.y + e.size/2, '#ff0055', 10);
                                enemies.splice(j, 1);
                            }
                            break;
                        }
                    }
                }
                
                // 게이트 충돌 (부정적일 때만)
                if (!bulletHit) {
                    for (let k = gates.length - 1; k >= 0; k--) {
                        let g = gates[k];
                        if (!g.isPositive &&
                            b.x > g.x && b.x < g.x + g.width &&
                            b.y > g.y && b.y < g.y + 80) {
                            
                            g.hit();
                            bulletHit = true;
                            createParticles(b.x, b.y, '#ff3333', 2);
                            break;
                        }
                    }
                }

                if (bulletHit) bullets.splice(i, 1);
            }

            // 보스 총알 vs 플레이어
            for (let i = bossBullets.length - 1; i >= 0; i--) {
                let b = bossBullets[i];
                // 플레이어 그룹은 원형으로 간주 (hitbox)
                let dx = playerGroup.x - b.x;
                let dy = playerGroup.y - b.y;
                let dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < playerGroup.width/2 + b.radius) {
                    // 피격
                    playerGroup.count -= 5; // 한 발당 5명 손실
                    createParticles(playerGroup.x, playerGroup.y, '#ff0000', 10);
                    bossBullets.splice(i, 1);
                }
            }

            // 플레이어 vs 객체
            // 게이트
            for (let i = gates.length - 1; i >= 0; i--) {
                let g = gates[i];
                if (playerGroup.x > g.x && playerGroup.x < g.x + g.width &&
                    playerGroup.y > g.y && playerGroup.y < g.y + 80) {
                    
                    if (g.type === 'add') playerGroup.count += g.value;
                    if (g.type === 'mult') playerGroup.count *= g.value;
                    if (g.type === 'sub') playerGroup.count -= g.value;
                    
                    if(playerGroup.count > 500) playerGroup.count = 500;
                    if(playerGroup.count < 0) playerGroup.count = 0;

                    const effectColor = g.isPositive ? '#00ff00' : '#ff0000';
                    createParticles(playerGroup.x, playerGroup.y, effectColor, 15);
                    gates.splice(i, 1);
                }
            }

            // 적
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                let dx = playerGroup.x - (e.x + e.size/2);
                let dy = playerGroup.y - (e.y + e.size/2);
                let dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < playerGroup.width/2 + e.size/2) {
                    playerGroup.count -= 10;
                    createParticles(playerGroup.x, playerGroup.y, '#ff0000', 10);
                    enemies.splice(i, 1);
                }
            }
            
            // 아이템
            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                let dx = playerGroup.x - (item.x + item.size/2);
                let dy = playerGroup.y - (item.y + item.size/2);
                let dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < playerGroup.width/2 + item.size/2) {
                    playerGroup.setWeapon(item.type); // 무기 획득
                    createParticles(playerGroup.x, playerGroup.y, '#ffff00', 20);
                    items.splice(i, 1);
                }
            }
            
            // 보스 몸통 박치기 (플레이어에게 큰 데미지)
            if (gameState === 'boss_fight' && currentBoss) {
                let dx = playerGroup.x - (currentBoss.x + currentBoss.width/2);
                let dy = playerGroup.y - (currentBoss.y + currentBoss.height/2);
                // 대략적인 거리 체크
                if (Math.abs(dx) < currentBoss.width/2 + 20 && Math.abs(dy) < currentBoss.height/2 + 20) {
                    playerGroup.count -= 1; // 매 프레임 데미지 (엄청 아픔)
                }
            }
        }

        function createParticles(x, y, color, count) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 1.0,
                    color: color
                });
            }
        }

        function updateParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.04;
                if(p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawParticles() {
            for(let p of particles) {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }

        function startBossPhase() {
            gameState = 'boss_fight';
            // 적과 게이트 제거 (아이템은 남겨둠)
            enemies = [];
            gates = [];
            bossBullets = []; // 보스 총알 초기화
            
            // 보스 생성
            currentBoss = new Boss(currentLevel);
            
            // UI 표시
            bossHpContainer.style.display = 'block';
            
            // 시각적 알림
            createParticles(canvas.width/2, 100, '#ff0000', 50);
        }

        function loop() {
            if (gameState !== 'playing' && gameState !== 'boss_fight') return;

            // 배경
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 레벨 타이머 (일반 진행 상태에서만)
            if (gameState === 'playing') {
                levelTimer++;
                if (levelTimer > levelDuration) {
                    levelTimer = 0;
                    startBossPhase();
                }
            }
            
            gameSpeed = baseGameSpeed + (currentLevel * 0.2);

            spawnTimer++;
            soldierCountEl.innerText = Math.floor(playerGroup.count);

            spawnEnemy();
            
            playerGroup.update();
            
            // 객체 업데이트 (스크롤)
            [roadMarkings, gates, enemies, items, bullets].forEach(arr => {
                for (let i = arr.length - 1; i >= 0; i--) {
                    if (arr[i] instanceof Enemy || arr[i] instanceof Item) {
                         // 보스전이 아닐때만 내려옴, 보스전엔 적 없음
                         if (gameState === 'playing' || arr[i] instanceof Item) {
                            arr[i].y += arr[i].speed * (gameSpeed / baseGameSpeed * 0.5); 
                         } else {
                             // 보스전 시작시 화면 밖으로 빠르게 내보내거나 삭제?
                             // 위 startBossPhase에서 enemies=[] 했으므로 여기 남은건 없음
                         }
                    } else if (arr[i] instanceof Gate || arr[i] instanceof RoadMark) {
                        arr[i].speed = gameSpeed;
                        arr[i].y += arr[i].speed;
                    } else {
                        arr[i].update(); // bullet
                    }
                    
                    if (arr[i].y > canvas.height + 100 || arr[i].y < -200) {
                        if(arr[i].y > canvas.height + 100) arr.splice(i, 1); 
                    }
                }
            });

            // 보스 총알 업데이트
            for (let i = bossBullets.length - 1; i >= 0; i--) {
                bossBullets[i].update();
                if (bossBullets[i].y > canvas.height + 50 || bossBullets[i].y < -50 || 
                    bossBullets[i].x < -50 || bossBullets[i].x > canvas.width + 50) {
                    bossBullets.splice(i, 1);
                }
            }
            
            // Draw
            roadMarkings.forEach(r => r.draw());
            gates.forEach(g => g.draw());
            items.forEach(i => i.draw());
            enemies.forEach(e => e.draw());
            
            if (currentBoss) {
                currentBoss.update();
                currentBoss.draw();
                // HP Bar Update
                const hpPercent = Math.max(0, (currentBoss.hp / currentBoss.maxHp) * 100);
                bossHpBar.style.width = hpPercent + '%';
            }

            bossBullets.forEach(b => b.draw()); // 보스 총알 그리기
            bullets.forEach(b => b.draw());
            playerGroup.draw();
            checkCollisions();
            updateParticles();
            drawParticles();

            if (playerGroup.count <= 0) {
                endGame();
                return;
            }

            animationId = requestAnimationFrame(loop);
        }

        function initGame() {
            playerGroup = new PlayerGroup();
            bullets = [];
            enemies = [];
            gates = [];
            items = [];
            particles = [];
            roadMarkings = [];
            bossBullets = []; // 초기화
            currentBoss = null;
            
            currentLevel = 1;
            levelTimer = 0;
            levelValEl.innerText = 1;
            gameSpeed = baseGameSpeed;
            
            spawnTimer = 0;
            inputX = canvas.width / 2;
            
            gameState = 'playing';
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            winScreen.classList.add('hidden');
            levelCompleteScreen.classList.add('hidden');
            bossHpContainer.style.display = 'none';

            resize();
            if(animationId) cancelAnimationFrame(animationId);
            loop();
        }

        function completeLevel() {
            bossHpContainer.style.display = 'none';
            if (currentLevel >= maxLevel) {
                winGame();
                return;
            }
            gameState = 'level_complete';
            completedLevelValEl.innerText = currentLevel;
            currentUnitsEl.innerText = Math.floor(playerGroup.count);
            levelCompleteScreen.classList.remove('hidden');
        }

        function startNextLevel() {
            currentLevel++;
            levelValEl.innerText = currentLevel;
            gameState = 'playing';
            levelCompleteScreen.classList.add('hidden');
            // 레벨 시작 시 무기 유지
            createParticles(canvas.width/2, canvas.height/2, '#ffff00', 30);
            loop();
        }

        function endGame() {
            gameState = 'gameover';
            finalLevelEl.innerText = currentLevel;
            gameOverScreen.classList.remove('hidden');
            bossHpContainer.style.display = 'none';
        }

        function winGame() {
            gameState = 'win';
            winScoreEl.innerText = playerGroup.count;
            winScreen.classList.remove('hidden');
            bossHpContainer.style.display = 'none';
        }

        startBtn.addEventListener('click', initGame);
        restartBtn.addEventListener('click', initGame);
        winRestartBtn.addEventListener('click', initGame);
        nextLevelBtn.addEventListener('click', startNextLevel);

    </script>
</body>
</html>
