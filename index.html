<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>솔저 러너 (Soldier Runner) - 밸런스 수정판</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #333; /* 도로 색상 */
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #score-board {
            margin-top: 20px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            padding: 5px 15px;
            border-radius: 15px;
        }

        #boss-hp-bar-container {
            display: none; /* 보스전일 때만 표시 */
            width: 80%;
            max-width: 400px;
            height: 20px;
            background: #555;
            border: 2px solid white;
            border-radius: 10px;
            margin-top: 10px;
            overflow: hidden;
        }

        #boss-hp-bar {
            width: 100%;
            height: 100%;
            background: #ff0055;
            transition: width 0.1s linear;
        }

        #level-indicator {
            margin-top: 10px;
            font-size: 18px;
            color: #ffff00;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }

        #start-screen, #game-over-screen, #win-screen, #level-complete-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px 40px;
            border-radius: 20px;
            border: 4px solid #0055ff;
            pointer-events: auto;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            width: 80%;
            max-width: 400px;
        }

        #win-screen {
            border-color: #00ff00;
            background: rgba(240, 255, 240, 0.95);
        }

        #win-screen h1 {
            color: #00aa00;
        }

        #level-complete-screen {
            border-color: #ffaa00;
        }
        
        #level-complete-screen h1 {
            color: #ffaa00;
        }

        h1 {
            margin: 0 0 15px 0;
            color: #0055ff;
            font-size: 28px;
            text-transform: uppercase;
        }

        p {
            font-size: 16px;
            color: #444;
            line-height: 1.5;
            margin-bottom: 20px;
        }

        .highlight {
            color: #ff0055;
            font-weight: bold;
        }

        .blue-highlight {
            color: #0055ff;
            font-weight: bold;
        }
        
        .green-highlight {
            color: #00aa00;
            font-weight: bold;
        }

        button {
            background: #0055ff;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 4px 0 #003399;
        }
        
        #next-level-btn {
            background: #ffaa00;
            box-shadow: 0 4px 0 #cc8800;
        }
        
        #next-level-btn:hover {
             background: #ffcc00;
        }

        button:hover {
            background: #1a6dff;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(2px);
            box-shadow: none;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="score-board">병력: <span id="soldier-count">1</span></div>
        <div id="level-indicator">LEVEL <span id="level-val">1</span> / 20</div>
        <!-- 보스 체력바 -->
        <div id="boss-hp-bar-container">
            <div id="boss-hp-bar"></div>
        </div>
    </div>

    <div id="start-screen">
        <h1>BOSS & WEAPON MOD</h1>
        <p>
            <strong>5판마다</strong> 강력한 보스가 등장합니다!<br>
            각 레벨은 <strong>20초</strong>간 진행됩니다.<br>
            <span style="color:#e6b800; font-weight:bold;">[M] 머신건</span>, <span style="color:#e6b800; font-weight:bold;">[S] 샷건</span> 아이템을 획득하세요.<br>
            <strong>주의: 레벨이 넘어가면 병력이 1명으로 초기화됩니다!</strong>
        </p>
        <button id="start-btn">작전 시작</button>
    </div>
    
    <div id="level-complete-screen" class="hidden">
        <h1>LEVEL CLEAR!</h1>
        <p>
            레벨 <span id="completed-level-val">1</span> 작전 성공.<br>
            다음 작전은 <strong>병력 1명</strong>으로 시작합니다.
        </p>
        <button id="next-level-btn">다음 작전으로</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>MISSION FAILED</h1>
        <p>도달 레벨: <span id="final-level">1</span></p>
        <button id="restart-btn">재도전</button>
    </div>

    <div id="win-screen" class="hidden">
        <h1>MISSION COMPLETE!</h1>
        <p>축하합니다! 모든 좀비와 보스를 물리쳤습니다.<br>최종 병력: <span id="win-score">0</span></p>
        <button id="win-restart-btn">다시 하기</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const soldierCountEl = document.getElementById('soldier-count');
        const levelValEl = document.getElementById('level-val');
        const finalLevelEl = document.getElementById('final-level');
        const winScoreEl = document.getElementById('win-score');
        
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const winScreen = document.getElementById('win-screen');
        const levelCompleteScreen = document.getElementById('level-complete-screen');
        const completedLevelValEl = document.getElementById('completed-level-val');
        const currentUnitsEl = document.getElementById('current-units');
        
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const winRestartBtn = document.getElementById('win-restart-btn');
        const nextLevelBtn = document.getElementById('next-level-btn');

        const bossHpContainer = document.getElementById('boss-hp-bar-container');
        const bossHpBar = document.getElementById('boss-hp-bar');

        // 게임 설정
        let gameState = 'start'; 
        let baseGameSpeed = 3; 
        let gameSpeed = baseGameSpeed;
        
        // 레벨 시스템 변수
        let currentLevel = 1;
        const maxLevel = 20;
        let levelTimer = 0;
        // 레벨 지속 시간 20초 (20초 * 60fps) -> 1200 프레임
        const levelDuration = 1200; 

        let spawnTimer = 0;
        let animationId;
        
        // 터치/마우스 입력
        let inputX = 0;

        // 객체 관리
        let playerGroup;
        let bullets = [];
        let enemies = [];
        let gates = [];
        let items = [];
        let particles = [];
        let roadMarkings = [];
        let currentBoss = null;
        let bossBullets = [];

        // 레인 정보
        let leftLaneX;
        let rightLaneX;
        let laneWidth;

        function resize() {
            canvas.width = Math.min(window.innerWidth, 600); 
            canvas.height = window.innerHeight;
            inputX = canvas.width / 2;

            laneWidth = canvas.width / 2;
            leftLaneX = laneWidth / 2;
            rightLaneX = laneWidth + laneWidth / 2;
            
            if (playerGroup) {
                playerGroup.targetX = inputX < canvas.width / 2 ? leftLaneX : rightLaneX;
            }
        }
        window.addEventListener('resize', resize);
        resize();

        function handleInputMove(clientX) {
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            inputX = Math.max(0, Math.min(canvas.width, x));
        }

        window.addEventListener('mousemove', (e) => {
            if(gameState === 'playing' || gameState === 'boss_fight') handleInputMove(e.clientX);
        });
        window.addEventListener('touchmove', (e) => {
            if(gameState === 'playing' || gameState === 'boss_fight') handleInputMove(e.touches[0].clientX);
        }, {passive: false});
        window.addEventListener('touchstart', (e) => {
             if(gameState === 'playing' || gameState === 'boss_fight') handleInputMove(e.touches[0].clientX);
        }, {passive: false});


        // 클래스: 플레이어 그룹
        class PlayerGroup {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height - 150;
                this.count = 1;
                this.width = 40;
                this.shootTimer = 0;
                this.targetX = this.x;
                
                // 무기 시스템
                this.weaponType = 'normal'; 
                this.weaponTimer = 0; 
            }

            setWeapon(type) {
                this.weaponType = type;
                this.shootTimer = 0; 
            }

            update() {
                this.targetX = inputX < canvas.width / 2 ? leftLaneX : rightLaneX;
                this.x += (this.targetX - this.x) * 0.2;
                this.width = 40 + Math.min(this.count * 2, 120);

                this.shootTimer++;
                let fireRate = 20; 
                
                if (this.weaponType === 'machinegun') {
                    fireRate = 5; 
                } else if (this.weaponType === 'shotgun') {
                    fireRate = 30; 
                } else {
                    fireRate = Math.max(8, 20 - Math.floor(this.count / 10));
                }

                if (this.shootTimer > fireRate) {
                    this.shoot();
                    this.shootTimer = 0;
                }
            }

            shoot() {
                let bulletCount = Math.min(this.count, 8); 
                let spread = this.width;

                if (this.weaponType === 'shotgun') {
                    for(let i=0; i<bulletCount; i++) {
                         let offsetX = (Math.random() - 0.5) * spread;
                         bullets.push(new Bullet(this.x + offsetX, this.y, 0, 'shotgun'));
                         bullets.push(new Bullet(this.x + offsetX, this.y, -2, 'shotgun'));
                         bullets.push(new Bullet(this.x + offsetX, this.y, 2, 'shotgun'));
                    }
                } else {
                    for(let i=0; i<bulletCount; i++) {
                        let offsetX = (Math.random() - 0.5) * spread;
                        bullets.push(new Bullet(this.x + offsetX, this.y, 0, this.weaponType));
                    }
                }
            }

            draw() {
                ctx.fillStyle = '#0055ff';
                const soldierSize = 8;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, soldierSize + 2, 0, Math.PI*2);
                ctx.fill();

                let drawCount = Math.min(this.count - 1, 30);
                for(let i=0; i<drawCount; i++) {
                    let angle = (Date.now() / 200) + (i * (Math.PI * 2 / drawCount));
                    let dist = 15 + (i % 2) * 10;
                    ctx.beginPath();
                    ctx.arc(this.x + Math.cos(angle)*dist, this.y + Math.sin(angle)*dist, soldierSize, 0, Math.PI*2);
                    ctx.fill();
                }

                ctx.fillStyle = 'white';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.count, this.x, this.y - 25);
                
                if (this.weaponType !== 'normal') {
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = '#ffff00';
                    ctx.fillText(this.weaponType === 'machinegun' ? "MACHINE GUN" : "SHOTGUN", this.x, this.y - 45);
                }
            }
        }

        class BossBullet {
            constructor(x, y, vx, vy) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.radius = 8;
                this.color = '#aa00ff'; 
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        class Bullet {
            constructor(x, y, vx = 0, type = 'normal') {
                this.x = x;
                this.y = y;
                this.radius = 3;
                this.speed = 15;
                this.vx = vx; 
                this.type = type;
                
                if (type === 'shotgun') {
                    this.damage = 1.5;
                    this.color = '#ffaa00';
                    this.radius = 4;
                } else if (type === 'machinegun') {
                    this.damage = 0.6; 
                    this.color = '#00ffff';
                    this.radius = 2.5;
                } else {
                    this.damage = 1;
                    this.color = '#ffcc00';
                }
            }

            update() {
                this.y -= this.speed;
                this.x += this.vx;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fill();
            }
        }

        class Item {
            constructor() {
                this.size = 40;
                this.x = (Math.random() < 0.5 ? leftLaneX : rightLaneX) - this.size / 2;
                this.y = -50;
                this.speed = gameSpeed;
                this.type = Math.random() < 0.5 ? 'machinegun' : 'shotgun';
            }
            
            update() {
                // this.y += this.speed; 
            }
            
            draw() {
                ctx.fillStyle = '#e6b800'; 
                ctx.fillRect(this.x, this.y, this.size, this.size);
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.strokeRect(this.x, this.y, this.size, this.size);
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.type === 'machinegun' ? 'M' : 'S', this.x + this.size/2, this.y + 28);
            }
        }

        class Enemy {
            constructor() {
                this.size = 40 + Math.random() * 20;
                this.x = (Math.random() < 0.5 ? leftLaneX : rightLaneX) - this.size / 2;
                this.y = -100;
                
                // 적 체력도 레벨 구간별로 차등
                let hpMultiplier = 1;
                if (currentLevel <= 10) hpMultiplier = 0.8;
                else if (currentLevel <= 15) hpMultiplier = 1.2;
                else if (currentLevel <= 19) hpMultiplier = 2.0;
                else hpMultiplier = 3.5;

                this.hp = Math.floor((3 + Math.random() * 5) * hpMultiplier * (currentLevel * 0.5)); 
                this.maxHp = this.hp;
                this.speed = gameSpeed * 0.8; 
                this.color = '#ff0055';
            }
            update() {}
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.hp, this.x + this.size/2, this.y + this.size/2 + 5);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.size, this.size);
            }
        }

        class Boss {
            constructor(level) {
                this.width = 100;
                this.height = 100;
                this.x = canvas.width / 2 - this.width / 2;
                this.y = -150; 
                this.targetY = 80;
                
                // 보스 체력 난이도 구간별 설정
                let baseBossHp = 50; 
                let levelFactor = 1;

                if (level <= 10) {
                    levelFactor = level * 10; 
                } else if (level <= 15) {
                    levelFactor = level * 20; 
                } else if (level <= 19) {
                    levelFactor = level * 40; 
                } else {
                    levelFactor = level * 60; 
                }

                this.maxHp = baseBossHp + levelFactor + (playerGroup.count * 2);
                this.hp = this.maxHp;
                
                this.moveTimer = 0;
                this.lane = 'center'; 
                this.state = 'entering'; 
                
                this.attackTimer = 0;
                // 공격 속도도 레벨별 차등
                let atkSpeedBase = 120;
                if (level > 10) atkSpeedBase = 90;
                if (level > 15) atkSpeedBase = 60;
                if (level == 20) atkSpeedBase = 30;

                this.attackInterval = Math.max(20, atkSpeedBase - (level)); 
            }

            update() {
                if (this.state === 'entering') {
                    this.y += (this.targetY - this.y) * 0.05;
                    if (Math.abs(this.y - this.targetY) < 5) {
                        this.state = 'fight';
                    }
                } else {
                    this.moveTimer++;
                    if (this.moveTimer > 120) { 
                        this.moveTimer = 0;
                        const rand = Math.random();
                        if (rand < 0.5) this.targetX = leftLaneX - this.width/2;
                        else this.targetX = rightLaneX - this.width/2;
                    }
                    
                    if (this.targetX !== undefined) {
                        this.x += (this.targetX - this.x) * 0.1;
                    }

                    this.attackTimer++;
                    if (this.attackTimer > this.attackInterval) {
                        this.shoot();
                        this.attackTimer = 0;
                    }
                }
            }

            shoot() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height;
                
                const dx = playerGroup.x - centerX;
                const dy = playerGroup.y - centerY;
                const angle = Math.atan2(dy, dx);
                const speed = 10; 

                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                bossBullets.push(new BossBullet(centerX, centerY, vx, vy));

                if (currentLevel >= 11) { // 11레벨부터 산탄 발사
                     const spreadAngle = 0.3; 
                     bossBullets.push(new BossBullet(centerX, centerY, Math.cos(angle - spreadAngle) * speed, Math.sin(angle - spreadAngle) * speed));
                     bossBullets.push(new BossBullet(centerX, centerY, Math.cos(angle + spreadAngle) * speed, Math.sin(angle + spreadAngle) * speed));
                }
                
                if (currentLevel >= 16) { // 16레벨부터 5발 산탄
                     const spreadAngle2 = 0.6; 
                     bossBullets.push(new BossBullet(centerX, centerY, Math.cos(angle - spreadAngle2) * speed, Math.sin(angle - spreadAngle2) * speed));
                     bossBullets.push(new BossBullet(centerX, centerY, Math.cos(angle + spreadAngle2) * speed, Math.sin(angle + spreadAngle2) * speed));
                }
            }

            draw() {
                ctx.fillStyle = '#aa0033';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.moveTo(this.x + 20, this.y + 30);
                ctx.lineTo(this.x + 40, this.y + 40);
                ctx.lineTo(this.x + 40, this.y + 25);
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(this.x + this.width - 20, this.y + 30);
                ctx.lineTo(this.x + this.width - 40, this.y + 40);
                ctx.lineTo(this.x + this.width - 40, this.y + 25);
                ctx.fill();

                ctx.lineWidth = 5;
                ctx.strokeStyle = '#ff0000';
                ctx.strokeRect(this.x, this.y, this.width, this.height);

                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("BOSS", this.x + this.width/2, this.y - 10);
            }
        }

        class Gate {
            constructor() {
                this.width = laneWidth * 0.8;
                this.height = 10;
                this.x = (Math.random() < 0.5 ? leftLaneX : rightLaneX) - this.width / 2;
                this.y = -50;
                this.speed = gameSpeed;
                this.isPositive = false;
                this.hp = 5;
                this.type = 'sub';
                
                // 게이트 값도 레벨에 따라 조정 (후반부엔 더 큰 값 필요)
                let valueBase = 5 + currentLevel;
                if (currentLevel > 15) valueBase += 10;

                this.value = Math.floor(Math.random() * valueBase) + valueBase;
            }

            hit() {
                if (this.isPositive) return;
                this.hp--;
                if (this.hp <= 0) this.transformToPositive();
            }

            transformToPositive() {
                this.isPositive = true;
                createParticles(this.x + this.width / 2, this.y + 40, '#0088ff', 20);
                const rand = Math.random();
                
                // 긍정적 게이트 보상
                if (rand < 0.7) {
                    this.type = 'add';
                    // 레벨이 높을수록 보상도 커야함 (초기화 되니까)
                    let addAmount = 10 + (currentLevel * 3); 
                    if (currentLevel > 15) addAmount += 20;
                    this.value = Math.floor(Math.random() * 10) + addAmount;
                } else {
                    this.type = 'mult';
                    this.value = Math.floor(Math.random() * 2) + 2;
                }
            }

            update() {}
            draw() {
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = !this.isPositive ? '#ff3333' : '#0088ff';
                ctx.fillRect(this.x, this.y, this.width, 80);
                ctx.globalAlpha = 1.0;

                ctx.fillStyle = 'white';
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                let text = (this.type === 'add' ? '+' : (this.type === 'mult' ? 'x' : '-')) + this.value;
                ctx.fillText(text, this.x + this.width/2, this.y + 50);

                 if (!this.isPositive) {
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText(`HP: ${this.hp}`, this.x + this.width/2, this.y + 75);
                }

                ctx.lineWidth = 3;
                ctx.strokeStyle = 'white';
                ctx.strokeRect(this.x, this.y, this.width, 80);
            }
        }

        class RoadMark {
            constructor() {
                this.x = canvas.width / 2 - 2;
                this.y = -100;
                this.width = 4;
                this.height = 60;
                this.speed = gameSpeed;
            }
            update() {}
            draw() {
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        function spawnEnemy() {
            if (gameState === 'boss_fight') return; 

            // 레벨 구간별 적 생성 확률 조정
            let spawnChance = 0.005; // 기본 (매우 낮음)

            if (currentLevel <= 10) {
                spawnChance = 0.005; // 0.5% (Lv 1-10: 아주 적음)
            } else if (currentLevel <= 15) {
                spawnChance = 0.015; // 1.5% (Lv 11-15: 조금 증가)
            } else if (currentLevel <= 19) {
                spawnChance = 0.03; // 3% (Lv 16-19: 많아짐)
            } else {
                spawnChance = 0.06; // 6% (Lv 20: 쏟아짐)
            }
            
            if (Math.random() < spawnChance) enemies.push(new Enemy());

            // 게이트 확률은 반대로 초반에 조금 더 넉넉하게, 후반에도 유지 (생존 필수)
            let gateChance = 0.02;
            if (Math.random() < gateChance) gates.push(new Gate());

            if (Math.random() < 0.005) items.push(new Item());

            if (roadMarkings.length === 0 || roadMarkings[roadMarkings.length-1].y > 200) {
                roadMarkings.push(new RoadMark());
            }
        }

        function checkCollisions() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                let bulletHit = false;

                if (gameState === 'boss_fight' && currentBoss) {
                    if (b.x > currentBoss.x && b.x < currentBoss.x + currentBoss.width &&
                        b.y > currentBoss.y && b.y < currentBoss.y + currentBoss.height) {
                        
                        currentBoss.hp -= b.damage;
                        bulletHit = true;
                        createParticles(b.x, b.y, '#ffaa00', 1);
                        
                        if (currentBoss.hp <= 0) {
                            createParticles(currentBoss.x + currentBoss.width/2, currentBoss.y + currentBoss.height/2, '#aa0033', 50);
                            currentBoss = null;
                            completeLevel();
                        }
                    }
                }

                if (!bulletHit) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        let e = enemies[j];
                        if (b.x > e.x && b.x < e.x + e.size &&
                            b.y > e.y && b.y < e.y + e.size) {
                            
                            e.hp -= b.damage;
                            bulletHit = true;
                            createParticles(b.x, b.y, '#ff0055', 2);
                            if (e.hp <= 0) {
                                createParticles(e.x + e.size/2, e.y + e.size/2, '#ff0055', 10);
                                enemies.splice(j, 1);
                            }
                            break;
                        }
                    }
                }
                
                if (!bulletHit) {
                    for (let k = gates.length - 1; k >= 0; k--) {
                        let g = gates[k];
                        if (!g.isPositive &&
                            b.x > g.x && b.x < g.x + g.width &&
                            b.y > g.y && b.y < g.y + 80) {
                            
                            g.hit();
                            bulletHit = true;
                            createParticles(b.x, b.y, '#ff3333', 2);
                            break;
                        }
                    }
                }

                if (bulletHit) bullets.splice(i, 1);
            }

            for (let i = bossBullets.length - 1; i >= 0; i--) {
                let b = bossBullets[i];
                let dx = playerGroup.x - b.x;
                let dy = playerGroup.y - b.y;
                let dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < playerGroup.width/2 + b.radius) {
                    playerGroup.count -= 5; 
                    createParticles(playerGroup.x, playerGroup.y, '#ff0000', 10);
                    bossBullets.splice(i, 1);
                }
            }

            for (let i = gates.length - 1; i >= 0; i--) {
                let g = gates[i];
                if (playerGroup.x > g.x && playerGroup.x < g.x + g.width &&
                    playerGroup.y > g.y && playerGroup.y < g.y + 80) {
                    
                    if (g.type === 'add') playerGroup.count += g.value;
                    if (g.type === 'mult') playerGroup.count *= g.value;
                    if (g.type === 'sub') playerGroup.count -= g.value;
                    
                    if(playerGroup.count > 500) playerGroup.count = 500;
                    if(playerGroup.count < 0) playerGroup.count = 0;

                    const effectColor = g.isPositive ? '#00ff00' : '#ff0000';
                    createParticles(playerGroup.x, playerGroup.y, effectColor, 15);
                    gates.splice(i, 1);
                }
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                let dx = playerGroup.x - (e.x + e.size/2);
                let dy = playerGroup.y - (e.y + e.size/2);
                let dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < playerGroup.width/2 + e.size/2) {
                    playerGroup.count -= 10;
                    createParticles(playerGroup.x, playerGroup.y, '#ff0000', 10);
                    enemies.splice(i, 1);
                }
            }
            
            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                let dx = playerGroup.x - (item.x + item.size/2);
                let dy = playerGroup.y - (item.y + item.size/2);
                let dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < playerGroup.width/2 + item.size/2) {
                    playerGroup.setWeapon(item.type); 
                    createParticles(playerGroup.x, playerGroup.y, '#ffff00', 20);
                    items.splice(i, 1);
                }
            }
            
            if (gameState === 'boss_fight' && currentBoss) {
                let dx = playerGroup.x - (currentBoss.x + currentBoss.width/2);
                let dy = playerGroup.y - (currentBoss.y + currentBoss.height/2);
                if (Math.abs(dx) < currentBoss.width/2 + 20 && Math.abs(dy) < currentBoss.height/2 + 20) {
                    playerGroup.count -= 1; 
                }
            }
        }

        function createParticles(x, y, color, count) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 1.0,
                    color: color
                });
            }
        }

        function updateParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.04;
                if(p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawParticles() {
            for(let p of particles) {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }

        function startBossPhase() {
            gameState = 'boss_fight';
            enemies = [];
            gates = [];
            bossBullets = []; 
            
            currentBoss = new Boss(currentLevel);
            
            bossHpContainer.style.display = 'block';
            createParticles(canvas.width/2, 100, '#ff0000', 50);
        }

        function loop() {
            if (gameState !== 'playing' && gameState !== 'boss_fight') return;

            ctx.fillStyle = '#333';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'playing') {
                levelTimer++;
                if (levelTimer > levelDuration) {
                    levelTimer = 0;
                    // 보스 등장 조건 수정: 5의 배수 레벨일 때만 보스 등장
                    if (currentLevel % 5 === 0) {
                        startBossPhase();
                    } else {
                        completeLevel();
                    }
                }
            }
            
            gameSpeed = baseGameSpeed + (currentLevel * 0.2);

            spawnTimer++;
            soldierCountEl.innerText = Math.floor(playerGroup.count);

            spawnEnemy();
            
            playerGroup.update();
            
            [roadMarkings, gates, enemies, items, bullets].forEach(arr => {
                for (let i = arr.length - 1; i >= 0; i--) {
                    if (arr[i] instanceof Enemy || arr[i] instanceof Item) {
                         if (gameState === 'playing' || arr[i] instanceof Item) {
                            arr[i].y += arr[i].speed * (gameSpeed / baseGameSpeed * 0.5); 
                         } 
                    } else if (arr[i] instanceof Gate || arr[i] instanceof RoadMark) {
                        arr[i].speed = gameSpeed;
                        arr[i].y += arr[i].speed;
                    } else {
                        arr[i].update(); 
                    }
                    
                    if (arr[i].y > canvas.height + 100 || arr[i].y < -200) {
                        if(arr[i].y > canvas.height + 100) arr.splice(i, 1); 
                    }
                }
            });

            for (let i = bossBullets.length - 1; i >= 0; i--) {
                bossBullets[i].update();
                if (bossBullets[i].y > canvas.height + 50 || bossBullets[i].y < -50 || 
                    bossBullets[i].x < -50 || bossBullets[i].x > canvas.width + 50) {
                    bossBullets.splice(i, 1);
                }
            }
            
            roadMarkings.forEach(r => r.draw());
            gates.forEach(g => g.draw());
            items.forEach(i => i.draw());
            enemies.forEach(e => e.draw());
            
            if (currentBoss) {
                currentBoss.update();
                currentBoss.draw();
                const hpPercent = Math.max(0, (currentBoss.hp / currentBoss.maxHp) * 100);
                bossHpBar.style.width = hpPercent + '%';
            }

            bossBullets.forEach(b => b.draw()); 
            bullets.forEach(b => b.draw());
            playerGroup.draw();
            checkCollisions();
            updateParticles();
            drawParticles();

            if (playerGroup.count <= 0) {
                endGame();
                return;
            }

            animationId = requestAnimationFrame(loop);
        }

        function initGame() {
            playerGroup = new PlayerGroup();
            bullets = [];
            enemies = [];
            gates = [];
            items = [];
            particles = [];
            roadMarkings = [];
            bossBullets = []; 
            currentBoss = null;
            
            currentLevel = 1;
            levelTimer = 0;
            levelValEl.innerText = 1;
            gameSpeed = baseGameSpeed;
            
            spawnTimer = 0;
            inputX = canvas.width / 2;
            
            gameState = 'playing';
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            winScreen.classList.add('hidden');
            levelCompleteScreen.classList.add('hidden');
            bossHpContainer.style.display = 'none';

            resize();
            if(animationId) cancelAnimationFrame(animationId);
            loop();
        }

        function completeLevel() {
            bossHpContainer.style.display = 'none';
            if (currentLevel >= maxLevel) {
                winGame();
                return;
            }
            gameState = 'level_complete';
            
            // 완료 문구 수정: 병력 초기화 안내
            completedLevelValEl.innerText = currentLevel;
            // currentUnitsEl.innerText = Math.floor(playerGroup.count); // 제거 또는 주석
            levelCompleteScreen.classList.remove('hidden');
        }

        function startNextLevel() {
            currentLevel++;
            levelValEl.innerText = currentLevel;
            gameState = 'playing';
            levelTimer = 0;
            spawnTimer = 0;
            levelCompleteScreen.classList.add('hidden');
            
            // 병력 초기화 (중요 요구사항)
            playerGroup.count = 1;
            soldierCountEl.innerText = 1; // UI 즉시 업데이트
            // 무기도 초기화할지 여부: 요구사항엔 없었으나 초기화가 "Restart" 느낌에 맞음
            playerGroup.setWeapon('normal');

            // 레벨 시작 효과
            createParticles(canvas.width/2, canvas.height/2, '#ffff00', 30);
            
            // 기존 총알/아이템 정리 (새로운 시작 느낌)
            bullets = [];
            items = [];
            enemies = []; // 혹시 남은 적 제거
            bossBullets = [];
            
            loop();
        }

        function endGame() {
            gameState = 'gameover';
            finalLevelEl.innerText = currentLevel;
            gameOverScreen.classList.remove('hidden');
            bossHpContainer.style.display = 'none';
        }

        function winGame() {
            gameState = 'win';
            winScoreEl.innerText = playerGroup.count;
            winScreen.classList.remove('hidden');
            bossHpContainer.style.display = 'none';
        }

        startBtn.addEventListener('click', initGame);
        restartBtn.addEventListener('click', initGame);
        winRestartBtn.addEventListener('click', initGame);
        nextLevelBtn.addEventListener('click', startNextLevel);

    </script>
</body>
</html>
