<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>솔저 러너 (Soldier Runner)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #333; /* 도로 색상 */
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #score-board {
            margin-top: 20px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            padding: 5px 15px;
            border-radius: 15px;
        }

        #level-indicator {
            margin-top: 10px;
            font-size: 18px;
            color: #ffff00;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }

        #start-screen, #game-over-screen, #win-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px 40px;
            border-radius: 20px;
            border: 4px solid #0055ff;
            pointer-events: auto;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            width: 80%;
            max-width: 400px;
        }

        #win-screen {
            border-color: #00ff00;
            background: rgba(240, 255, 240, 0.95);
        }

        #win-screen h1 {
            color: #00aa00;
        }

        h1 {
            margin: 0 0 15px 0;
            color: #0055ff;
            font-size: 28px;
            text-transform: uppercase;
        }

        p {
            font-size: 16px;
            color: #444;
            line-height: 1.5;
            margin-bottom: 20px;
        }

        .highlight {
            color: #ff0055;
            font-weight: bold;
        }

        .blue-highlight {
            color: #0055ff;
            font-weight: bold;
        }

        button {
            background: #0055ff;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 4px 0 #003399;
        }

        button:hover {
            background: #1a6dff;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(2px);
            box-shadow: none;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="score-board">병력: <span id="soldier-count">1</span></div>
        <div id="level-indicator">LEVEL <span id="level-val">1</span> / 20</div>
    </div>

    <div id="start-screen">
        <h1>SOLDIER RUN</h1>
        <p>
            총 20개의 레벨을 돌파하세요!<br>
            2분 동안 생존하면 승리합니다.<br>
            <span class="blue-highlight">파란 게이트</span>를 통과해 병력을 늘리고,<br>
            <span class="highlight">빨간 적</span>들을 물리치세요!
        </p>
        <button id="start-btn">작전 시작</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>MISSION FAILED</h1>
        <p>도달 레벨: <span id="final-level">1</span></p>
        <button id="restart-btn">재도전</button>
    </div>

    <div id="win-screen" class="hidden">
        <h1>MISSION COMPLETE!</h1>
        <p>축하합니다! 모든 좀비를 물리쳤습니다.<br>최종 병력: <span id="win-score">0</span></p>
        <button id="win-restart-btn">다시 하기</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const soldierCountEl = document.getElementById('soldier-count');
        const levelValEl = document.getElementById('level-val');
        const finalLevelEl = document.getElementById('final-level');
        const winScoreEl = document.getElementById('win-score');
        
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const winScreen = document.getElementById('win-screen');
        
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const winRestartBtn = document.getElementById('win-restart-btn');

        // 게임 설정
        let gameState = 'start'; 
        let baseGameSpeed = 4;
        let gameSpeed = baseGameSpeed;
        
        // 레벨 시스템 변수
        let currentLevel = 1;
        const maxLevel = 20;
        let levelTimer = 0;
        const levelDuration = 360; // 약 6초 (60fps 기준) -> 20레벨 * 6초 = 120초(2분)

        let spawnTimer = 0;
        let animationId;
        
        // 터치/마우스 입력
        let inputX = 0;
        let isTouching = false;

        // 객체 관리
        let playerGroup;
        let bullets = [];
        let enemies = [];
        let gates = [];
        let particles = [];
        let roadMarkings = [];

        function resize() {
            canvas.width = Math.min(window.innerWidth, 600); // 모바일 비율 유지
            canvas.height = window.innerHeight;
            inputX = canvas.width / 2;
        }
        window.addEventListener('resize', resize);
        resize();

        // 입력 핸들러
        function handleInputMove(clientX) {
            // 캔버스 내의 상대적 위치 계산
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            inputX = Math.max(0, Math.min(canvas.width, x));
        }

        window.addEventListener('mousemove', (e) => {
            if(gameState === 'playing') handleInputMove(e.clientX);
        });
        window.addEventListener('touchmove', (e) => {
            if(gameState === 'playing') handleInputMove(e.touches[0].clientX);
        }, {passive: false});

        // 클래스: 플레이어 그룹 (병사들)
        class PlayerGroup {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height - 150;
                this.count = 1;
                this.width = 40; // 군집의 대략적 너비
                this.shootTimer = 0;
            }

            update() {
                // 부드러운 이동 (Lerp)
                this.x += (inputX - this.x) * 0.15;
                
                // 너비는 병사 수에 따라 조금씩 커짐 (최대치 제한)
                this.width = 40 + Math.min(this.count * 2, 120);

                // 자동 발사
                this.shootTimer++;
                // 병사가 많을수록 발사 속도가 빨라지거나 탄막이 많아짐
                let fireRate = Math.max(4, 20 - Math.floor(this.count / 5)); 
                
                if (this.shootTimer > fireRate) {
                    this.shoot();
                    this.shootTimer = 0;
                }
            }

            shoot() {
                // 병사 수에 비례하여 총알 발사 (너무 많으면 렉 걸리므로 제한)
                let bulletCount = Math.min(this.count, 8); // 한번에 최대 8발 (후반부 위해 증가)
                let spread = this.width;
                
                for(let i=0; i<bulletCount; i++) {
                    let offsetX = (Math.random() - 0.5) * spread;
                    bullets.push(new Bullet(this.x + offsetX, this.y));
                }
            }

            draw() {
                // 중앙 리더와 주변 병사들 그리기
                ctx.fillStyle = '#0055ff';
                
                // 단순화를 위해 병사를 작은 원으로 표현
                const soldierSize = 8;
                
                // 시각적 연출: 병사들이 뭉쳐있는 모습
                // 리더
                ctx.beginPath();
                ctx.arc(this.x, this.y, soldierSize + 2, 0, Math.PI*2);
                ctx.fill();

                // 나머지 병사들 (랜덤 오프셋이지만 프레임마다 고정된 느낌을 주기 위해 간단히 처리)
                // 실제로는 배열로 관리해야 겠지만, 성능상 시각적 효과만 줌
                let drawCount = Math.min(this.count - 1, 20); // 최대 20명만 그림
                
                for(let i=0; i<drawCount; i++) {
                    // 간단한 원형 배치
                    let angle = (Date.now() / 200) + (i * (Math.PI * 2 / drawCount));
                    let dist = 15 + (i % 2) * 10;
                    ctx.beginPath();
                    ctx.arc(this.x + Math.cos(angle)*dist, this.y + Math.sin(angle)*dist, soldierSize, 0, Math.PI*2);
                    ctx.fill();
                }

                // 숫자 표시
                ctx.fillStyle = 'white';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.count, this.x, this.y - 25);
            }
        }

        class Bullet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 3;
                this.speed = 15;
                this.damage = 1;
            }

            update() {
                this.y -= this.speed;
            }

            draw() {
                ctx.fillStyle = '#ffcc00';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fill();
            }
        }

        class Enemy {
            constructor() {
                this.size = 40 + Math.random() * 20;
                this.x = Math.random() * (canvas.width - this.size);
                this.y = -100;
                
                // 레벨 기반 체력 증가
                let hpMultiplier = 1 + (currentLevel * 0.5); // 레벨 20이면 11배
                this.hp = Math.floor((5 + Math.random() * 5) * hpMultiplier); 
                
                this.maxHp = this.hp;
                
                // 레벨 기반 속도 증가
                let speedMultiplier = 1 + (currentLevel * 0.05); // 레벨 20이면 2배 속도
                this.speed = gameSpeed * 0.8 * speedMultiplier; 
                
                this.color = '#ff0055';
            }

            update() {
                this.y += this.speed;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                
                // HP 텍스트
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.hp, this.x + this.size/2, this.y + this.size/2 + 5);
                
                // 테두리
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.size, this.size);
            }
        }

        class Gate {
            constructor() {
                this.width = 120;
                this.height = 10; // 얇은 통과선
                this.x = Math.random() * (canvas.width - this.width);
                this.y = -50;
                this.speed = gameSpeed;
                
                // 레벨에 따른 게이트 확률 조정
                // 레벨 1~5: 좋은 게이트 위주
                // 레벨 15~20: 함정이나 곱하기 위주
                const rand = Math.random();
                let difficultyFactor = currentLevel / maxLevel; // 0.05 ~ 1.0

                if (difficultyFactor < 0.3) {
                    // 초반: 대부분 덧셈/곱셈
                    if (rand < 0.6) this.setup('add', 5, 15);
                    else if (rand < 0.9) this.setup('mult', 2, 3);
                    else this.setup('sub', 5, 10);
                } else {
                    // 후반: 함정 증가
                    if (rand < 0.4) this.setup('add', 10, 30); // 보상도 커짐
                    else if (rand < 0.7) this.setup('mult', 2, 4);
                    else this.setup('sub', 10 + (currentLevel*2), 20 + (currentLevel*2));
                }
            }

            setup(type, minVal, maxVal) {
                this.type = type;
                this.value = Math.floor(Math.random() * (maxVal - minVal)) + minVal;
            }

            update() {
                this.y += this.speed;
            }

            draw() {
                // 게이트 본체 (반투명 막)
                ctx.globalAlpha = 0.6;
                if (this.type === 'sub') {
                    ctx.fillStyle = '#ff3333'; // 빨강
                } else {
                    ctx.fillStyle = '#0088ff'; // 파랑
                }
                ctx.fillRect(this.x, this.y, this.width, 80); // 판정박스보다 시각적으로 길게
                ctx.globalAlpha = 1.0;

                // 텍스트
                ctx.fillStyle = 'white';
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                let text = '';
                if (this.type === 'add') text = '+' + this.value;
                if (this.type === 'mult') text = 'x' + this.value;
                if (this.type === 'sub') text = '-' + this.value;
                
                ctx.fillText(text, this.x + this.width/2, this.y + 50);

                // 테두리
                ctx.lineWidth = 3;
                ctx.strokeStyle = 'white';
                ctx.strokeRect(this.x, this.y, this.width, 80);
            }
        }

        class RoadMark {
            constructor() {
                this.x = canvas.width / 2 - 5;
                this.y = -100;
                this.width = 10;
                this.height = 60;
                this.speed = gameSpeed;
            }
            update() { this.y += this.speed; }
            draw() {
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        function spawnEnemy() {
            // 난이도 계수 (0 ~ 1)
            let difficulty = currentLevel / maxLevel; 

            // 적 생성 확률: 레벨 1은 매우 낮음, 레벨 20은 매우 높음
            // 기본 2% + (난이도 * 15%)
            let spawnChance = 0.02 + (difficulty * 0.15);
            
            if (Math.random() < spawnChance) { 
                enemies.push(new Enemy());
            }

            // 게이트 생성 (적이 너무 많으면 게이트로 구원)
            // 후반부일수록 게이트도 자주 나와야 버틸 수 있음
            let gateChance = 0.01 + (difficulty * 0.02);
            if (Math.random() < gateChance) {
                gates.push(new Gate());
            }

            // 도로 표시
            if (roadMarkings.length === 0 || roadMarkings[roadMarkings.length-1].y > 200) {
                roadMarkings.push(new RoadMark());
            }
        }

        function checkCollisions() {
            // 총알 vs 적
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                for (let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    if (b.x > e.x && b.x < e.x + e.size &&
                        b.y > e.y && b.y < e.y + e.size) {
                        
                        e.hp -= b.damage;
                        bullets.splice(i, 1);
                        
                        // 타격 효과
                        createParticles(b.x, b.y, '#ff0055', 3);

                        if (e.hp <= 0) {
                            createParticles(e.x + e.size/2, e.y + e.size/2, '#ff0055', 10);
                            enemies.splice(j, 1);
                        }
                        break;
                    }
                }
            }

            // 플레이어 vs 게이트
            // 플레이어 중심점 기준
            for (let i = gates.length - 1; i >= 0; i--) {
                let g = gates[i];
                // 게이트 판정 (y좌표가 플레이어를 지나칠 때)
                // 간단한 AABB 충돌
                if (playerGroup.x > g.x && playerGroup.x < g.x + g.width &&
                    playerGroup.y > g.y && playerGroup.y < g.y + 80) {
                    
                    // 효과 적용
                    if (g.type === 'add') playerGroup.count += g.value;
                    if (g.type === 'mult') playerGroup.count *= g.value;
                    if (g.type === 'sub') playerGroup.count -= g.value;
                    
                    // 최대치 제한 (너무 많으면 렉 걸림)
                    if(playerGroup.count > 300) playerGroup.count = 300;

                    createParticles(playerGroup.x, playerGroup.y, '#00ff00', 10);
                    gates.splice(i, 1); // 통과하면 사라짐
                }
            }

            // 플레이어 vs 적 (충돌)
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                // 거리 기반 충돌 (플레이어 그룹은 원형으로 간주)
                let dx = playerGroup.x - (e.x + e.size/2);
                let dy = playerGroup.y - (e.y + e.size/2);
                let dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < playerGroup.width/2 + e.size/2) {
                    // 병력 손실
                    playerGroup.count -= 5; // 한 번 부딪히면 5명 손실
                    createParticles(playerGroup.x, playerGroup.y, '#ff0000', 5);
                    enemies.splice(i, 1); // 적은 자폭
                }
            }
        }

        function createParticles(x, y, color, count) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    life: 1.0,
                    color: color
                });
            }
        }

        function updateParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                if(p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawParticles() {
            for(let p of particles) {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }

        function loop() {
            if (gameState !== 'playing') return;

            // 배경 클리어
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 레벨 시스템 업데이트
            levelTimer++;
            if (levelTimer > levelDuration) {
                levelTimer = 0;
                if (currentLevel < maxLevel) {
                    currentLevel++;
                    levelValEl.innerText = currentLevel;
                    // 레벨업 시각 효과 (간단히)
                    createParticles(canvas.width/2, canvas.height/2, '#ffff00', 20);
                } else {
                    // 레벨 20 완료 후 시간 경과 -> 승리!
                    winGame();
                    return;
                }
            }
            
            // 난이도에 따른 게임 속도 점진적 증가
            gameSpeed = baseGameSpeed + (currentLevel * 0.2);

            spawnTimer++;
            soldierCountEl.innerText = Math.floor(playerGroup.count);

            spawnEnemy();
            
            playerGroup.update();
            
            // 객체 업데이트 및 그리기
            [roadMarkings, gates, enemies, bullets].forEach(arr => {
                for (let i = arr.length - 1; i >= 0; i--) {
                    // 객체 속도 업데이트 (전역 gameSpeed 반영)
                    if(arr[i] instanceof Enemy) {
                        // 적은 고유 속도 로직이 있으나 게임 빨라지면 같이 빨라져야 함
                        // Enemy 클래스 내에서 속도 결정하므로 여기선 패스하거나 보정
                        arr[i].y += arr[i].speed * (gameSpeed / baseGameSpeed * 0.5); 
                    } else {
                        arr[i].speed = gameSpeed; // 게이트, 도로 등은 게임 속도 따라감
                        arr[i].update();
                    }
                    
                    if (arr[i].y > canvas.height + 100 || arr[i].y < -200) {
                        if(arr[i].y > canvas.height + 100) arr.splice(i, 1); 
                    } else {
                        // 적 draw는 update 안에서 안하므로 여기서 호출
                         if(!(arr[i] instanceof Enemy)) arr[i].draw(); // Enemy는 별도 드로우 로직 없음? 아 위 코드에 있음.
                         // 기존 코드 구조상 Enemy.update() 내에서 y증가만 하고 draw는 별도였음. 
                         // 하지만 위 for문에서 update()를 호출하고 있음.
                         // Enemy.draw()를 호출해야 함.
                    }
                }
            });
            
            // Enemy, Bullet 등 draw 분리
            roadMarkings.forEach(r => r.draw());
            gates.forEach(g => g.draw());
            enemies.forEach(e => {
                e.update(); // 위에서 update 호출 안하도록 수정 필요하나 복잡하니 여기서 그냥 처리
                e.draw();
            });
            bullets.forEach(b => {
                // bullet은 위에서 update 호출됨
                b.draw();
            });


            playerGroup.draw();
            checkCollisions();

            updateParticles();
            drawParticles();

            // 게임 오버 체크
            if (playerGroup.count <= 0) {
                endGame();
                return;
            }

            animationId = requestAnimationFrame(loop);
        }

        function initGame() {
            playerGroup = new PlayerGroup();
            bullets = [];
            enemies = [];
            gates = [];
            particles = [];
            roadMarkings = [];
            
            // 레벨 초기화
            currentLevel = 1;
            levelTimer = 0;
            levelValEl.innerText = 1;
            gameSpeed = baseGameSpeed;
            
            spawnTimer = 0;
            inputX = canvas.width / 2;
            
            gameState = 'playing';
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            winScreen.classList.add('hidden');
            
            if(animationId) cancelAnimationFrame(animationId);
            loop();
        }

        function endGame() {
            gameState = 'gameover';
            finalLevelEl.innerText = currentLevel;
            gameOverScreen.classList.remove('hidden');
        }

        function winGame() {
            gameState = 'win';
            winScoreEl.innerText = playerGroup.count;
            winScreen.classList.remove('hidden');
        }

        startBtn.addEventListener('click', initGame);
        restartBtn.addEventListener('click', initGame);
        winRestartBtn.addEventListener('click', initGame);

    </script>
</body>
</html>
